<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic Usage · PolyChaos.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/PolyChaos/stable/pce_tutorial/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PolyChaos.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PolyChaos.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../type_hierarchy/">Type Hierarchy</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../numerical_integration/">Numerical Integration</a></li><li><a class="tocitem" href="../quadrature_rules/">Quadrature Rules</a></li><li><a class="tocitem" href="../orthogonal_polynomials_canonical/">Univariate Monic Orthogonal Polynomials</a></li><li><a class="tocitem" href="../gaussian_mixture_model/">Gaussian Mixture Models</a></li><li><a class="tocitem" href="../multiple_discretization/">Multiple Discretization</a></li><li><a class="tocitem" href="../scalar_products/">Computation of Scalar Products</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox" checked/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Polynomial Chaos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Basic Usage</a><ul class="internal"><li><a class="tocitem" href="#Construction-of-Basis"><span>Construction of Basis</span></a></li><li><a class="tocitem" href="#Finding-PCE-Coefficients"><span>Finding PCE Coefficients</span></a></li><li><a class="tocitem" href="#Moments"><span>Moments</span></a></li><li><a class="tocitem" href="#Sampling"><span>Sampling</span></a></li></ul></li><li><a class="tocitem" href="../chi_squared_k1/">Chi Squared, One DOF</a></li><li><a class="tocitem" href="../chi_squared_k_greater1/">Chi Squared, Several DOFs</a></li><li><a class="tocitem" href="../random_ode/">Random ODE</a></li></ul></li><li><a class="tocitem" href="../DCsOPF/">Optimal Power Flow</a></li></ul></li><li><a class="tocitem" href="../math/">Mathematical Background</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Usage</a></li><li><a class="is-disabled">Polynomial Chaos</a></li><li class="is-active"><a href>Basic Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic Usage</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/PolyChaos.jl/blob/master/docs/src/pce_tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CommonRandomVariables"><a class="docs-heading-anchor" href="#CommonRandomVariables">Common Random Variables</a><a id="CommonRandomVariables-1"></a><a class="docs-heading-anchor-permalink" href="#CommonRandomVariables" title="Permalink"></a></h1><p>Polynomial chaos expansion (PCE) is a Hilbert space technique for random variables with finite variance. Mathematically equivalent to Fourier series expansions for periodic signals, PCE allows characterizing a random variable in terms of its PCE coefficients (aka Fourier coefficients). That is, the PCE of a random variable <span>$\mathsf{x}$</span> is given by</p><p class="math-container">\[\mathsf{x} = \sum_{i=0}^L x_i \phi_i,\]</p><p>where <span>$x_i$</span> are the so-called PCE coefficients, and <span>$\phi_i$</span> are the orthogonal polynomials that are orthogonal relative to the probability density function of <span>$\mathsf{x}$</span>.</p><p>This tutorial walks you through the PCE of common random variables, namely Gaussian (<code>gaussian</code>), Beta (<code>beta01</code>), Uniform(<code>uniform01</code>), Logistic (<code>logistic</code>), and shows how they are implemented in <code>PolyChaos</code>.</p><h2 id="Construction-of-Basis"><a class="docs-heading-anchor" href="#Construction-of-Basis">Construction of Basis</a><a id="Construction-of-Basis-1"></a><a class="docs-heading-anchor-permalink" href="#Construction-of-Basis" title="Permalink"></a></h2><pre><code class="language-julia hljs">using PolyChaos</code></pre><p>The orthogonal polynomials are constructed using the <code>OrthoPoly</code>-type (here of degree at most <code>d</code>). For canonical measures, special constructors are implemented:</p><pre><code class="language-julia hljs">d = 6

myops = Dict()
polynames = [&quot;gaussian&quot;, &quot;beta01&quot;, &quot;uniform01&quot;, &quot;logistic&quot;]

# gaussian
gaussian = GaussOrthoPoly(d);
myops[&quot;gaussian&quot;] = gaussian

# beta01
α, β = 1.3, 2.2
beta01 = Beta01OrthoPoly(d, α, β);
myops[&quot;beta01&quot;] = beta01

# uniform01
uniform01 = Uniform01OrthoPoly(d);
myops[&quot;uniform01&quot;] = uniform01

# logistic
logistic = LogisticOrthoPoly(d);
myops[&quot;logistic&quot;] = logistic;

myops</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Any, Any} with 4 entries:
  &quot;uniform01&quot; =&gt; Uniform01OrthoPoly{Vector{Float64}, Uniform01Measure, Quad{Flo…
  &quot;logistic&quot;  =&gt; LogisticOrthoPoly{Vector{Float64}, LogisticMeasure, Quad{Float…
  &quot;beta01&quot;    =&gt; Beta01OrthoPoly{Vector{Float64}, Beta01Measure, Quad{Float64, …
  &quot;gaussian&quot;  =&gt; GaussOrthoPoly{Vector{Float64}, GaussMeasure, Quad{Float64, Ve…</code></pre><p>For example, let&#39;s evaluate the Gaussian basis polynomials at some points</p><pre><code class="language-julia hljs">points, degrees = randn(10), 0:2:d

[evaluate(degree, points, gaussian) for degree in degrees]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Vector{Float64}}:
 [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
 [-0.952379914633003, 0.11432344180772014, -0.6501886935354688, 2.1344484730659423, 1.4985895201890798, 0.9740528376603825, 0.3430571355413754, -0.9800111524468413, -0.980219888183326, -0.9993704383096359]
 [2.7165471603283784, -2.444223917884117, 1.0235001113432352, -5.981923608090236, -5.748587530735783, -4.947432420087287, -3.254540343919648, 2.8804664687075516, 2.8817105819234357, 2.996223026205737]
 [-12.891003259681058, 17.902477950539033, -1.0512047685479207, 9.473899476645265, 19.390852974167043, 23.07176472085471, 20.80314383697176, -14.106487183880887, -14.115756021577273, -14.971675668902918]</code></pre><h2 id="Finding-PCE-Coefficients"><a class="docs-heading-anchor" href="#Finding-PCE-Coefficients">Finding PCE Coefficients</a><a id="Finding-PCE-Coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-PCE-Coefficients" title="Permalink"></a></h2><p>Having constructed the orthogonal bases, the question remains how to find the PCE coefficients for the common random variables. Every random variable can be characterized exactly by two PCE coefficients. For a Gaussian random variable, this is familiar: the mean and the variance suffice to describe a Gaussian random variable entirely. The same is true for any random variable of finite variance given the right basis. The function <code>convert2affinePCE</code> provides the first two PCE coefficients (hence the name affine) for the common random variables.</p><h3 id="Gaussian"><a class="docs-heading-anchor" href="#Gaussian">Gaussian</a><a id="Gaussian-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian" title="Permalink"></a></h3><p>Given the Gaussian random variable <span>$\mathsf{x} \sim \mathcal{N}(\mu, \sigma^2)$</span> with <span>$\sigma &gt; 0$</span>, the affine PCE coefficients are</p><pre><code class="language-julia hljs"># Gaussian
μ, σ = 2.0, 0.2
pce_gaussian = convert2affinePCE(μ, σ, gaussian)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 2.0
 0.2</code></pre><h3 id="Uniform"><a class="docs-heading-anchor" href="#Uniform">Uniform</a><a id="Uniform-1"></a><a class="docs-heading-anchor-permalink" href="#Uniform" title="Permalink"></a></h3><p>Given the uniform random variable <span>$\mathsf{x} \sim \mathcal{U}(a, b)$</span> with finite support <span>$a&lt;b$</span>, the affine PCE coefficients are</p><pre><code class="language-julia hljs">a, b = -0.3, 1.2
convert2affinePCE(a, b, uniform01)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 0.45
 1.5</code></pre><p>Instead, if the expected value and standard deviation are known, the affine PCE coefficients of the uniform random variable are</p><pre><code class="language-julia hljs">pce_uniform = convert2affinePCE(μ, σ, uniform01; kind = &quot;μσ&quot;)
# notice that the zero-order coefficient IS equivalent to the expected value μ</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 2.0
 0.6928203230275509</code></pre><h3 id="Beta"><a class="docs-heading-anchor" href="#Beta">Beta</a><a id="Beta-1"></a><a class="docs-heading-anchor-permalink" href="#Beta" title="Permalink"></a></h3><p>Given the Beta random variable <span>$\mathsf{x} \sim \mathcal{B}(a, b, \alpha, \beta)$</span> with finite support <span>$a&lt;b$</span> and shape parameters <span>$\alpha, \beta &gt; 0$</span>, the affine PCE coefficients are</p><pre><code class="language-julia hljs">convert2affinePCE(a, b, beta01)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 0.2571428571428572
 1.5</code></pre><p>Instead, if the expected value and standard deviation are known, the affine PCE coefficients of the uniform random variable are</p><pre><code class="language-julia hljs">pce_beta = convert2affinePCE(μ, σ, beta01; kind = &quot;μσ&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 2.0
 0.8780541105074454</code></pre><h3 id="Logistic"><a class="docs-heading-anchor" href="#Logistic">Logistic</a><a id="Logistic-1"></a><a class="docs-heading-anchor-permalink" href="#Logistic" title="Permalink"></a></h3><p>Given the logistic random variable <span>$\mathsf{x} \sim \mathcal{L}(a_1,a_2)$</span> where <span>$a_2&gt;0$</span> with the probability density function</p><p class="math-container">\[\rho(t) = \frac{1}{4 a_2} \, \operatorname{sech}^2 \left(\frac{t-a_1}{2a_2}\right)\]</p><p>the affine PCE coefficients of the uniform random variable are</p><pre><code class="language-julia hljs">a1, a2 = μ, sqrt(3) * σ / pi
pce_logistic = convert2affinePCE(a1, a2, logistic)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 2.0
 0.11026577908435842</code></pre><h2 id="Moments"><a class="docs-heading-anchor" href="#Moments">Moments</a><a id="Moments-1"></a><a class="docs-heading-anchor-permalink" href="#Moments" title="Permalink"></a></h2><p>It is a key feature of PCE to compute moments from the PCE coefficients alone; no sampling is required.</p><h3 id="Gaussian-2"><a class="docs-heading-anchor" href="#Gaussian-2">Gaussian</a><a class="docs-heading-anchor-permalink" href="#Gaussian-2" title="Permalink"></a></h3><pre><code class="language-julia hljs">mean(pce_gaussian, myops[&quot;gaussian&quot;]), std(pce_gaussian, myops[&quot;gaussian&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(2.0, 0.2)</code></pre><h3 id="Uniform-2"><a class="docs-heading-anchor" href="#Uniform-2">Uniform</a><a class="docs-heading-anchor-permalink" href="#Uniform-2" title="Permalink"></a></h3><pre><code class="language-julia hljs">mean(pce_uniform, myops[&quot;uniform01&quot;]), std(pce_uniform, myops[&quot;uniform01&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(2.0, 0.19999999999999998)</code></pre><h3 id="Beta-2"><a class="docs-heading-anchor" href="#Beta-2">Beta</a><a class="docs-heading-anchor-permalink" href="#Beta-2" title="Permalink"></a></h3><pre><code class="language-julia hljs">mean(pce_beta, myops[&quot;beta01&quot;]), std(pce_beta, myops[&quot;beta01&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(2.0, 0.20000000000000004)</code></pre><h3 id="Logistic-2"><a class="docs-heading-anchor" href="#Logistic-2">Logistic</a><a class="docs-heading-anchor-permalink" href="#Logistic-2" title="Permalink"></a></h3><pre><code class="language-julia hljs">mean(pce_logistic, myops[&quot;logistic&quot;]), std(pce_logistic, myops[&quot;logistic&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(2.0, 0.2)</code></pre><h2 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h2><p>Having found the PCE coefficients, it may be useful to sample the random variables. That means, find <span>$N$</span> realizations of the random variable that obey the random variable&#39;s probability density function. This is done in two steps:</p><ol><li>Draw <span>$N$</span> samples from the measure (<code>sampleMeasure()</code>), and then</li><li>Evaluate the basis polynomials and multiply times the PCE coefficients, i.e. <span>$\sum_{i=0}^L x_i \phi_i(\xi_j)$</span> where <span>$\xi_j$</span> is the <span>$j$</span>-th sample from the measure (<code>evaluatePCE()</code>).</li></ol><p>Both steps are combined in the function <code>samplePCE()</code>.</p><h3 id="Gaussian-3"><a class="docs-heading-anchor" href="#Gaussian-3">Gaussian</a><a class="docs-heading-anchor-permalink" href="#Gaussian-3" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Statistics
N = 1000
ξ_gaussian = sampleMeasure(N, myops[&quot;gaussian&quot;])
samples_gaussian = evaluatePCE(pce_gaussian, ξ_gaussian, myops[&quot;gaussian&quot;])
# samplePCE(N,pce_gaussian,myops[&quot;gaussian&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1000-element Vector{Float64}:
 1.9962995622479847
 2.406004429229373
 1.9943402517826734
 1.9371916661891109
 2.167390279845841
 1.9926175976046259
 1.8903062118096048
 2.1036343482249458
 2.0537390048784014
 1.7573864638793806
 ⋮
 2.2269659830119943
 2.208210410342416
 1.6992582441025044
 2.015317908225613
 1.9034050566635383
 2.065213016372206
 1.8423671628761216
 2.274869964143386
 1.8000278065259703</code></pre><h3 id="Uniform-3"><a class="docs-heading-anchor" href="#Uniform-3">Uniform</a><a class="docs-heading-anchor-permalink" href="#Uniform-3" title="Permalink"></a></h3><pre><code class="language-julia hljs">ξ_uniform = sampleMeasure(N, myops[&quot;uniform01&quot;])
samples_uniform = evaluatePCE(pce_uniform, ξ_uniform, myops[&quot;uniform01&quot;])
# samples_uniform = samplePCE(N,pce_uniform,myops[&quot;uniform01&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1000-element Vector{Float64}:
 2.2552201757166475
 2.1362658579593043
 1.961941134504637
 2.1161138411170435
 2.308922004793409
 2.119517492052187
 1.7951432763113573
 1.9217967768425326
 1.753826842665235
 1.9633739902088427
 ⋮
 2.0521331861129277
 2.0679140833450846
 1.6681851010602262
 1.75902295855054
 1.9311786783690035
 1.9584748714259022
 2.2221394005813737
 2.269511274010926
 2.154598018486945</code></pre><h3 id="Beta-3"><a class="docs-heading-anchor" href="#Beta-3">Beta</a><a class="docs-heading-anchor-permalink" href="#Beta-3" title="Permalink"></a></h3><pre><code class="language-julia hljs">ξ_beta = sampleMeasure(N, myops[&quot;beta01&quot;])
samples_beta = evaluatePCE(pce_beta, ξ_beta, myops[&quot;beta01&quot;])
# samples_beta = samplePCE(N,pce_beta,myops[&quot;beta01&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1000-element Vector{Float64}:
 1.6847434234070877
 1.6937146057579968
 2.1808846749137953
 1.776326184187671
 1.8503090602268635
 1.7413558597938188
 1.9326831378326284
 1.8577282860022457
 1.784895088318576
 2.0497870908892644
 ⋮
 2.3411103846142307
 2.1307295186147743
 1.7609030946574054
 2.1768584821134085
 2.1463955798303664
 2.039401132718851
 1.834579539981725
 2.0853053613569825
 2.0818386437275267</code></pre><h3 id="Logistic-3"><a class="docs-heading-anchor" href="#Logistic-3">Logistic</a><a class="docs-heading-anchor-permalink" href="#Logistic-3" title="Permalink"></a></h3><pre><code class="language-julia hljs">ξ_logistic = sampleMeasure(N, myops[&quot;logistic&quot;])
samples_logistic = evaluatePCE(pce_logistic, ξ_logistic, myops[&quot;logistic&quot;])
# samples_logistic = samplePCE(N,pce_logistic,myops[&quot;logistic&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1000-element Vector{Float64}:
 1.9647553752644638
 2.2945919389128875
 1.92780610167665
 1.9272446207929246
 2.167827002858176
 2.3743275643851764
 1.8737005811512943
 1.789972615176257
 2.0114120520333634
 1.7893316359572533
 ⋮
 1.726712078107279
 2.261438733628451
 1.9628683783132423
 1.9539506190171896
 2.1906307535313885
 2.1344650603312996
 2.176912737827542
 2.090598300812237
 1.8411528562239314</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../scalar_products/">« Computation of Scalar Products</a><a class="docs-footer-nextpage" href="../chi_squared_k1/">Chi Squared, One DOF »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 2 December 2023 15:00">Saturday 2 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
