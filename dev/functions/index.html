<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · PolyChaos.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/PolyChaos/stable/functions/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PolyChaos.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PolyChaos.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../type_hierarchy/">Type Hierarchy</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../numerical_integration/">Numerical Integration</a></li><li><a class="tocitem" href="../quadrature_rules/">Quadrature Rules</a></li><li><a class="tocitem" href="../orthogonal_polynomials_canonical/">Univariate Monic Orthogonal Polynomials</a></li><li><a class="tocitem" href="../gaussian_mixture_model/">Gaussian Mixture Models</a></li><li><a class="tocitem" href="../multiple_discretization/">Multiple Discretization</a></li><li><a class="tocitem" href="../scalar_products/">Computation of Scalar Products</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Polynomial Chaos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../pce_tutorial/">Basic Usage</a></li><li><a class="tocitem" href="../chi_squared_k1/">Chi Squared, One DOF</a></li><li><a class="tocitem" href="../chi_squared_k_greater1/">Chi Squared, Several DOFs</a></li><li><a class="tocitem" href="../random_ode/">Random ODE</a></li></ul></li><li><a class="tocitem" href="../DCsOPF/">Optimal Power Flow</a></li></ul></li><li><a class="tocitem" href="../math/">Mathematical Background</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Recurrence-Coefficients-for-Monic-Orthogonal-Polynomials"><span>Recurrence Coefficients for Monic Orthogonal Polynomials</span></a></li><li><a class="tocitem" href="#Show-Orthogonal-Polynomials"><span>Show Orthogonal Polynomials</span></a></li><li><a class="tocitem" href="#Evaluate-Orthogonal-Polynomials"><span>Evaluate Orthogonal Polynomials</span></a></li><li><a class="tocitem" href="#Scalar-Products"><span>Scalar Products</span></a></li><li><a class="tocitem" href="#Quadrature-Rules"><span>Quadrature Rules</span></a></li><li><a class="tocitem" href="#Polynomial-Chaos"><span>Polynomial Chaos</span></a></li><li><a class="tocitem" href="#Auxiliary-Functions"><span>Auxiliary Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/PolyChaos.jl/blob/master/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The core interface of all essential functions are <em>not</em> dependent on specialized types such as <code>AbstractOrthoPoly</code>. Having said that, for exactly those essential functions, there exist overloaded functions that accept specialized types such as <code>AbstractOrthoPoly</code> as arguments.</p><p>Too abstract? For example, the function <code>evaluate</code> that evaluates a polynomial of degree <code>n</code> at points <code>x</code> has the core interface</p><pre><code class="nohighlight hljs">    evaluate(n::Int,x::Array{&lt;:Real},a::Vector{&lt;:Real},b::Vector{&lt;:Real})</code></pre><p>where <code>a</code> and <code>b</code> are the vectors of recurrence coefficients. For simplicity, there also exists the interface</p><pre><code class="nohighlight hljs">    evaluate(n::Int64,x::Vector{&lt;:Real},op::AbstractOrthoPoly)</code></pre><p>So fret not upon the encounter of multiple-dispatched versions of the same thing. It&#39;s there to simplify your life.</p><p>The idea of this approach is to make it simpler for others to copy and paste code snippets and use them in their own work.</p></div></div><p>List of all functions in <code>PolyChaos</code>.</p><ul><li><a href="#LinearAlgebra.issymmetric"><code>LinearAlgebra.issymmetric</code></a></li><li><a href="#PolyChaos.calculateAffinePCE"><code>PolyChaos.calculateAffinePCE</code></a></li><li><a href="#PolyChaos.clenshaw_curtis"><code>PolyChaos.clenshaw_curtis</code></a></li><li><a href="#PolyChaos.coeffs"><code>PolyChaos.coeffs</code></a></li><li><a href="#PolyChaos.computeSP"><code>PolyChaos.computeSP</code></a></li><li><a href="#PolyChaos.computeSP2"><code>PolyChaos.computeSP2</code></a></li><li><a href="#PolyChaos.convert2affinePCE"><code>PolyChaos.convert2affinePCE</code></a></li><li><a href="#PolyChaos.evaluate"><code>PolyChaos.evaluate</code></a></li><li><a href="#PolyChaos.evaluatePCE"><code>PolyChaos.evaluatePCE</code></a></li><li><a href="#PolyChaos.fejer"><code>PolyChaos.fejer</code></a></li><li><a href="#PolyChaos.fejer2"><code>PolyChaos.fejer2</code></a></li><li><a href="#PolyChaos.gauss"><code>PolyChaos.gauss</code></a></li><li><a href="#PolyChaos.integrate"><code>PolyChaos.integrate</code></a></li><li><a href="#PolyChaos.lanczos"><code>PolyChaos.lanczos</code></a></li><li><a href="#PolyChaos.lobatto"><code>PolyChaos.lobatto</code></a></li><li><a href="#PolyChaos.mcdiscretization"><code>PolyChaos.mcdiscretization</code></a></li><li><a href="#PolyChaos.nw"><code>PolyChaos.nw</code></a></li><li><a href="#PolyChaos.quadgp"><code>PolyChaos.quadgp</code></a></li><li><a href="#PolyChaos.r_scale"><code>PolyChaos.r_scale</code></a></li><li><a href="#PolyChaos.radau"><code>PolyChaos.radau</code></a></li><li><a href="#PolyChaos.rec2coeff"><code>PolyChaos.rec2coeff</code></a></li><li><a href="#PolyChaos.rm_compute"><code>PolyChaos.rm_compute</code></a></li><li><a href="#PolyChaos.rm_hermite"><code>PolyChaos.rm_hermite</code></a></li><li><a href="#PolyChaos.rm_hermite_prob"><code>PolyChaos.rm_hermite_prob</code></a></li><li><a href="#PolyChaos.rm_jacobi"><code>PolyChaos.rm_jacobi</code></a></li><li><a href="#PolyChaos.rm_jacobi01"><code>PolyChaos.rm_jacobi01</code></a></li><li><a href="#PolyChaos.rm_laguerre"><code>PolyChaos.rm_laguerre</code></a></li><li><a href="#PolyChaos.rm_legendre"><code>PolyChaos.rm_legendre</code></a></li><li><a href="#PolyChaos.rm_legendre01"><code>PolyChaos.rm_legendre01</code></a></li><li><a href="#PolyChaos.rm_logistic"><code>PolyChaos.rm_logistic</code></a></li><li><a href="#PolyChaos.rm_meixner_pollaczek"><code>PolyChaos.rm_meixner_pollaczek</code></a></li><li><a href="#PolyChaos.sampleMeasure"><code>PolyChaos.sampleMeasure</code></a></li><li><a href="#PolyChaos.samplePCE"><code>PolyChaos.samplePCE</code></a></li><li><a href="#PolyChaos.showbasis"><code>PolyChaos.showbasis</code></a></li><li><a href="#PolyChaos.showpoly"><code>PolyChaos.showpoly</code></a></li><li><a href="#PolyChaos.stieltjes"><code>PolyChaos.stieltjes</code></a></li><li><a href="#Statistics.mean"><code>Statistics.mean</code></a></li><li><a href="#Statistics.std"><code>Statistics.std</code></a></li><li><a href="#Statistics.var"><code>Statistics.var</code></a></li></ul><h2 id="Recurrence-Coefficients-for-Monic-Orthogonal-Polynomials"><a class="docs-heading-anchor" href="#Recurrence-Coefficients-for-Monic-Orthogonal-Polynomials">Recurrence Coefficients for Monic Orthogonal Polynomials</a><a id="Recurrence-Coefficients-for-Monic-Orthogonal-Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrence-Coefficients-for-Monic-Orthogonal-Polynomials" title="Permalink"></a></h2><p>The functions below provide analytic expressions for the recurrence coefficients of common orthogonal polynomials. All of these provide <em>monic orthogonal polynomials</em> relative to the weights.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The number <code>N</code> of recurrence coefficients has to be positive for all functions below.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.r_scale" href="#PolyChaos.r_scale"><code>PolyChaos.r_scale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">r_scale(c::Real,β::AbstractVector{&lt;:Real},α::AbstractVector{&lt;:Real})</code></pre><p>Given the recursion coefficients <code>(α,β)</code> for a system of orthogonal polynomials that are orthogonal with respect to some positive weight <span>$m(t)$</span>, this function returns the recursion coefficients <code>(α_,β_)</code> for the scaled measure <span>$c m(t)$</span> for some positive <span>$c$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/recurrence_coefficients_monic.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.rm_compute" href="#PolyChaos.rm_compute"><code>PolyChaos.rm_compute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rm_compute(weight::Function,lb::Real,ub::Real,Npoly::Int=4,Nquad::Int=10;quadrature::Function=clenshaw_curtis)</code></pre><p>Given a positive <code>weight</code> function with domain <code>(lb,ub)</code>, i.e. a function <span>$w: [lb, ub ] \rightarrow \mathbb{R}_{\geq 0}$</span>, this function creates <code>Npoly</code> recursion coefficients <code>(α,β)</code>.</p><p>The keyword <code>quadrature</code> specifies what quadrature rule is being used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/recurrence_coefficients_monic.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.rm_logistic" href="#PolyChaos.rm_logistic"><code>PolyChaos.rm_logistic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rm_logistic(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic polynomials that are orthogonal on <span>$(-\infty,\infty)$</span> relative to <span>$w(t) = \frac{\mathrm{e}^{-t}}{(1 - \mathrm{e}^{-t})^2}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/recurrence_coefficients_monic.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.rm_hermite" href="#PolyChaos.rm_hermite"><code>PolyChaos.rm_hermite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rm_hermite(N::Int,mu::Real)
rm_hermite(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic generalized Hermite polynomials that are orthogonal on <span>$(-\infty,\infty)$</span> relative to <span>$w(t) = |t|^{2 \mu} \mathrm{e}^{-t^2}$</span></p><p>The call <code>rm_hermite(N)</code> is the same as <code>rm_hermite(N,0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/recurrence_coefficients_monic.jl#L96-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.rm_hermite_prob" href="#PolyChaos.rm_hermite_prob"><code>PolyChaos.rm_hermite_prob</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rm_hermite_prob(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic probabilists&#39; Hermite polynomials that are orthogonal on <span>$(-\infty,\infty)$</span> relative to <span>$w(t) = \mathrm{e}^{-0.5t^2}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/recurrence_coefficients_monic.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.rm_laguerre" href="#PolyChaos.rm_laguerre"><code>PolyChaos.rm_laguerre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rm_laguerre(N::Int,a::Real)
rm_laguerre(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic generalized Laguerre polynomials that are orthogonal on <span>$(0,\infty)$</span> relative to <span>$w(t) = t^a \mathrm{e}^{-t}$</span>.</p><p>The call <code>rm_laguerre(N)</code> is the same as <code>rm_laguerre(N,0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/recurrence_coefficients_monic.jl#L127-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.rm_legendre" href="#PolyChaos.rm_legendre"><code>PolyChaos.rm_legendre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rm_legendre(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic Legendre polynomials that are orthogonal on <span>$(-1,1)$</span> relative to <span>$w(t) = 1$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/recurrence_coefficients_monic.jl#L199-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.rm_legendre01" href="#PolyChaos.rm_legendre01"><code>PolyChaos.rm_legendre01</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rm_legendre01(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic Legendre polynomials that are orthogonal on <span>$(0,1)$</span> relative to <span>$w(t) = 1$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/recurrence_coefficients_monic.jl#L207-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.rm_jacobi" href="#PolyChaos.rm_jacobi"><code>PolyChaos.rm_jacobi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rm_jacobi(N::Int,a::Real,b::Real)
rm_jacobi(N::Int,a::Real)
rm_jacobi(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic Jacobi polynomials that are orthogonal on <span>$(-1,1)$</span> relative to <span>$w(t) = (1-t)^a (1+t)^b$</span>.</p><p>The call <code>rm_jacobi(N,a)</code> is the same as <code>rm_jacobi(N,a,a)</code> and <code>rm_jacobi(N)</code> the same as <code>rm_jacobi(N,0,0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/recurrence_coefficients_monic.jl#L148-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.rm_jacobi01" href="#PolyChaos.rm_jacobi01"><code>PolyChaos.rm_jacobi01</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rm_jacobi01(N::Int,a::Real,b::Real)
rm_jacobi01(N::Int,a::Real)
rm_jacobi01(N::Int)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic Jacobi polynomials that are orthogonal on <span>$(0,1)$</span> relative to <span>$w(t) = (1-t)^a t^b$</span>.</p><p>The call <code>rm_jacobi01(N,a)</code> is the same as <code>rm_jacobi01(N,a,a)</code> and <code>rm_jacobi01(N)</code> the same as <code>rm_jacobi01(N,0,0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/recurrence_coefficients_monic.jl#L179-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.rm_meixner_pollaczek" href="#PolyChaos.rm_meixner_pollaczek"><code>PolyChaos.rm_meixner_pollaczek</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rm_meixner_pollaczek(N::Int,lambda::Real,phi::Real)
rm_meixner_pollaczek(N::Int,lambda::Real)</code></pre><p>Creates <code>N</code> recurrence coefficients for monic Meixner-Pollaczek polynomials with parameters λ and ϕ. These are orthogonal on <span>$[-\infty,\infty]$</span> relative to the weight function <span>$w(t)=(2 \pi)^{-1} \exp{(2 \phi-\pi)t} |\Gamma(\lambda+ i t)|^2$</span>.</p><p>The call <code>rm_meixner_pollaczek(n,lambda)</code> is the same as <code>rm_meixner_pollaczek(n,lambda,pi/2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/recurrence_coefficients_monic.jl#L215-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.stieltjes" href="#PolyChaos.stieltjes"><code>PolyChaos.stieltjes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stieltjes(N::Int,nodes_::AbstractVector{&lt;:Real},weights_::AbstractVector{&lt;:Real};removezeroweights::Bool=true)</code></pre><p>Stieltjes procedure–-Given the nodes and weights, the function generates the first<code>N</code> recurrence coefficients of the corresponding discrete orthogonal polynomials.</p><p>Set the Boolean <code>removezeroweights</code> to <code>true</code> if zero weights should be removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/stieltjes.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.lanczos" href="#PolyChaos.lanczos"><code>PolyChaos.lanczos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lanczos(N::Int,nodes::AbstractVector{&lt;:Real},weights::AbstractVector{&lt;:Real};removezeroweights::Bool=true)</code></pre><p>Lanczos procedure–-given the nodes and weights, the function generates the first <code>N</code> recurrence coefficients of the corresponding discrete orthogonal polynomials.</p><p>Set the Boolean <code>removezeroweights</code> to <code>true</code> if zero weights should be removed.</p><p>The script is adapted from the routine RKPW in W.B. Gragg and W.J. Harrod, <em>The numerically stable reconstruction of Jacobi matrices from spectral data</em>, Numer. Math. 44 (1984), 317-335.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/stieltjes.jl#L54-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.mcdiscretization" href="#PolyChaos.mcdiscretization"><code>PolyChaos.mcdiscretization</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mcdiscretization(N::Int,quads::Vector{},discretemeasure::AbstractMatrix{&lt;:Real}=zeros(0,2);discretization::Function=stieltjes,Nmax::Integer=300,ε::Float64=1e-8,gaussquad::Bool=false)</code></pre><p>This routine returns <span>$N$</span> recurrence coefficients of the polynomials that are orthogonal relative to a weight function <span>$w$</span> that is decomposed as a sum of <span>$m$</span> weights <span>$w_i$</span> with domains <span>$[a_i,b_i]$</span> for <span>$i=1,\dots,m$</span>,</p><p class="math-container">\[w(t) = \sum_{i}^{m} w_i(t) \quad \text{with } \operatorname{dom}(w_i) = [a_i, b_i].\]</p><p>For each weight <span>$w_i$</span> and its domain <span>$[a_i, b_i]$</span> the function <code>mcdiscretization()</code> expects a quadrature rule of the form nodes::AbstractVector{&lt;:Real}, weights::AbstractVector{&lt;:Real} = my<em>quad</em>i(N::Int) all of which are stacked in the parameter <code>quad</code> quad = [ my<em>quad</em>1, ..., my<em>quad</em>m ] If the weight function has a discrete part (specified by <code>discretemeasure</code>) it is added on to the discretized continuous weight function.</p><p>The function <code>mcdiscretization()</code> performs a sequence of discretizations of the given weight <span>$w(t)$</span>, each discretization being followed by an application of the Stieltjes or Lanczos procedure (keyword <code>discretization in [stieltjes, lanczos]</code>) to produce approximations to the desired recurrence coefficients. The function applies to each subinterval <span>$i$</span> an <code>N</code>-point quadrature rule (the <span>$i$</span>th entry of <code>quad</code>) to discretize the weight function <span>$w_i$</span> on that subinterval. If the procedure converges to within a prescribed accuracy <code>ε</code> before <code>N</code> reaches its maximum allowed value <code>Nmax</code>. If the function does not converge, the function prompts an error message.</p><p>The keyword <code>gaussquad</code> should be set to <code>true</code> if Gauss quadrature rules are available <em>for all</em> <span>$m$</span> weights <span>$w_i(t)$</span> with <span>$i = 1, \dots, m$</span>.</p><p>For further information, please see W. Gautschi &quot;Orthogonal Polynomials: Approximation and Computation&quot;, Section 2.2.4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/stieltjes.jl#L99-L134">source</a></section></article><h2 id="Show-Orthogonal-Polynomials"><a class="docs-heading-anchor" href="#Show-Orthogonal-Polynomials">Show Orthogonal Polynomials</a><a id="Show-Orthogonal-Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Show-Orthogonal-Polynomials" title="Permalink"></a></h2><p>To get a human-readable output of the orthogonal polynomials, there is the function <code>showpoly</code></p><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.showpoly" href="#PolyChaos.showpoly"><code>PolyChaos.showpoly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">showpoly(coeffs::Vector{&lt;:Real};sym::String,digits::Integer)</code></pre><p>Show the monic polynomial with coefficients <code>coeffs</code> in a human-readable way. The keyword <code>sym</code> sets the name of the variable, and <code>digits</code> controls the number of shown digits.</p><pre><code class="language-julia-repl hljs">julia&gt; using PolyChaos

julia&gt; showpoly([1.2, 2.3, 3.4456])
x^3 + 3.45x^2 + 2.3x + 1.2

julia&gt; showpoly([1.2, 2.3, 3.4456], sym = &quot;t&quot;, digits = 2)
t^3 + 3.45t^2 + 2.3t + 1.2</code></pre><pre><code class="nohighlight hljs">showpoly(d::Integer,α::Vector{&lt;:Real},β::Vector{&lt;:Real}; sym::String,digits::Integer)
showpoly(d::Range,α::Vector{&lt;:Real},β::Vector{&lt;:Real};sym::String,digits::Integer) where Range &lt;: OrdinalRange</code></pre><p>Show the monic polynomial of degree/range <code>d</code> that has the recurrence coefficients <code>α</code>, <code>β</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using PolyChaos

julia&gt; α, β = rm_hermite(10)
([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1.77245, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5])

julia&gt; showpoly(3, α, β)
x^3 - 1.5x

julia&gt; showpoly(0:2:10, α, β)
1
x^2 - 0.5
x^4 - 3.0x^2 + 0.75
x^6 - 7.5x^4 + 11.25x^2 - 1.88
x^8 - 14.0x^6 + 52.5x^4 - 52.5x^2 + 6.56
x^10 - 22.5x^8 + 157.5x^6 - 393.75x^4 + 295.31x^2 - 29.53</code></pre><p>Tailored to types from <code>PolyChaos.jl</code></p><pre><code class="nohighlight hljs">showpoly(d::Union{Integer,Range},op::AbstractOrthoPoly;sym::String,digits::Integer) where Range &lt;: OrdinalRange</code></pre><p>Show the monic polynomial of degree/range <code>d</code> of an <code>AbstractOrthoPoly</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using PolyChaos

julia&gt; op = GaussOrthoPoly(5);

julia&gt; showpoly(3, op)
x^3 - 3.0x

julia&gt; showpoly(0:(op.deg), op; sym = &quot;t&quot;)
1
t
t^2 - 1.0
t^3 - 3.0t
t^4 - 6.0t^2 + 3.0
t^5 - 10.0t^3 + 15.0t</code></pre><p><a href="https://discourse.julialang.org/t/how-to-define-verbose-output-for-a-polynomial/21317/5">Thanks @pfitzseb for providing this functionality.</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/show.jl#L104-L173">source</a></section></article><p>In case you want to see the entire basis, just use <code>showbasis</code></p><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.showbasis" href="#PolyChaos.showbasis"><code>PolyChaos.showbasis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">showbasis(α::Vector{&lt;:Real},β::Vector{&lt;:Real};sym::String,digits::Integer)</code></pre><p>Show all basis polynomials given the recurrence coefficients <code>α</code>, <code>β</code>. The keyword <code>sym</code> sets the name of the variable, and <code>digits</code> controls the number of shown digits.</p><pre><code class="language-julia-repl hljs">julia&gt; using PolyChaos

julia&gt; α, β = rm_hermite(5);

julia&gt; showbasis(α, β)
1
x
x^2 - 0.5
x^3 - 1.5x
x^4 - 3.0x^2 + 0.75
x^5 - 5.0x^3 + 3.75x</code></pre><p>Tailored to types from <code>PolyChaos.jl</code></p><pre><code class="nohighlight hljs">showbasis(op::AbstractOrthoPoly;sym::String,digits::Integer)</code></pre><p>Show all basis polynomials of an <code>AbstractOrthoPoly</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using PolyChaos

julia&gt; op = LegendreOrthoPoly(4);

julia&gt; showbasis(op)
1
x
x^2 - 0.33
x^3 - 0.6x
x^4 - 0.86x^2 + 0.09</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/show.jl#L206-L248">source</a></section></article><p>Both of these functions make excessive use of</p><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.rec2coeff" href="#PolyChaos.rec2coeff"><code>PolyChaos.rec2coeff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rec2coeff(deg::Int,a::Vector{&lt;:Real},b::Vector{&lt;:Real})
rec2coeff(a,b) = rec2coeff(length(a),a,b)</code></pre><p>Get the coefficients of the orthogonal polynomial of degree up to <code>deg</code> specified by its recurrence coefficients <code>(a,b)</code>. The function returns the values <span>$c_i^{(k)}$</span> from</p><p class="math-container">\[p_k (t) = t^d + \sum_{i=0}^{k-1} c_i t^i,\]</p><p>where <span>$k$</span> runs from <code>1</code> to <code>deg</code>.</p><p>The call <code>rec2coeff(a,b)</code> outputs all possible recurrence coefficients given <code>(a,b)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/show.jl#L65-L81">source</a></section></article><h2 id="Evaluate-Orthogonal-Polynomials"><a class="docs-heading-anchor" href="#Evaluate-Orthogonal-Polynomials">Evaluate Orthogonal Polynomials</a><a id="Evaluate-Orthogonal-Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluate-Orthogonal-Polynomials" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.evaluate" href="#PolyChaos.evaluate"><code>PolyChaos.evaluate</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Univariate</strong></p><pre><code class="nohighlight hljs">evaluate(n::Int,x::Array{&lt;:Real},a::AbstractVector{&lt;:Real},b::AbstractVector{&lt;:Real})
evaluate(n::Int,x::Real,a::AbstractVector{&lt;:Real},b::AbstractVector{&lt;:Real})
evaluate(n::Int,x::AbstractVector{&lt;:Real},op::AbstractOrthoPoly)
evaluate(n::Int,x::Real,op::AbstractOrthoPoly)</code></pre><p>Evaluate the <code>n</code>-th univariate basis polynomial at point(s) <code>x</code> The function is multiple-dispatched to facilitate its use with the composite type <code>AbstractOrthoPoly</code></p><p>If several basis polynomials (stored in <code>ns</code>) are to be evaluated at points <code>x</code>, then call</p><pre><code class="nohighlight hljs">evaluate(ns::AbstractVector{&lt;:Int},x::AbstractVector{&lt;:Real},op::AbstractOrthoPoly) = evaluate(ns,x,op.α,op.β)
evaluate(ns::AbstractVector{&lt;:Int},x::Real,op::AbstractOrthoPoly) = evaluate(ns,[x],op)</code></pre><p>If <em>all</em> basis polynomials are to be evaluated at points <code>x</code>, then call</p><pre><code class="nohighlight hljs">evaluate(x::AbstractVector{&lt;:Real},op::AbstractOrthoPoly) = evaluate(collect(0:op.deg),x,op)
evaluate(x::Real,op::AbstractOrthoPoly) = evaluate([x],op)</code></pre><p>which returns an Array of dimensions <code>(length(x),op.deg+1)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li><code>n</code> is the degree of the univariate basis polynomial</li><li><code>length(x) = N</code>, where <code>N</code> is the number of points</li><li><code>(a,b)</code> are the recursion coefficients</li></ul></div></div><p><strong>Multivariate</strong></p><pre><code class="nohighlight hljs">evaluate(n::AbstractVector{&lt;:Int},x::AbstractMatrix{&lt;:Real},a::Vector{&lt;:AbstractVector{&lt;:Real}},b::Vector{&lt;:AbstractVector{&lt;:Real}})
evaluate(n::AbstractVector{&lt;:Int},x::AbstractVector{&lt;:Real},a::Vector{&lt;:AbstractVector{&lt;:Real}},b::Vector{&lt;:AbstractVector{&lt;:Real}})
evaluate(n::AbstractVector{&lt;:Int},x::AbstractMatrix{&lt;:Real},op::MultiOrthoPoly)
evaluate(n::AbstractVector{&lt;:Int},x::AbstractVector{&lt;:Real},op::MultiOrthoPoly)</code></pre><p>Evaluate the n-th p-variate basis polynomial at point(s) x The function is multiply dispatched to facilitate its use with the composite type <code>MultiOrthoPoly</code></p><p>If several basis polynomials are to be evaluated at points <code>x</code>, then call</p><pre><code class="nohighlight hljs">evaluate(ind::AbstractMatrix{&lt;:Int},x::AbstractMatrix{&lt;:Real},a::Vector{&lt;:AbstractVector{&lt;:Real}},b::Vector{&lt;:AbstractVector{&lt;:Real}})
evaluate(ind::AbstractMatrix{&lt;:Int},x::AbstractMatrix{&lt;:Real},op::MultiOrthoPoly)</code></pre><p>where <code>ind</code> is a matrix of multi-indices.</p><p>If <em>all</em> basis polynomials are to be evaluated at points <code>x</code>, then call</p><pre><code class="nohighlight hljs">evaluate(x::AbstractMatrix{&lt;:Real},mop::MultiOrthoPoly) = evaluate(mop.ind,x,mop)</code></pre><p>which returns an array of dimensions <code>(mop.dim,size(x,1))</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li><code>n</code> is a multi-index</li><li><code>length(n) == p</code>, i.e. a p-variate basis polynomial</li><li><code>size(x) = (N,p)</code>, where <code>N</code> is the number of points</li><li><code>size(a)==size(b)=p</code>.</li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/evaluate.jl#L3-L73">source</a></section></article><h2 id="Scalar-Products"><a class="docs-heading-anchor" href="#Scalar-Products">Scalar Products</a><a id="Scalar-Products-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-Products" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.computeSP2" href="#PolyChaos.computeSP2"><code>PolyChaos.computeSP2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">computeSP2(n::Integer,β::AbstractVector{&lt;:Real})
computeSP2(n::Integer,op::AbstractOrthoPoly) = computeSP2(n,op.β)
computeSP2(op::AbstractOrthoPoly) = computeSP2(op.deg,op.β)</code></pre><p>Computes the <code>n</code> <em>regular</em> scalar products aka 2-norms of the orthogonal polynomials, namely</p><p class="math-container">\[\|ϕ_i\|^2 = \langle \phi_i,\phi_i\rangle \quad \forall i \in \{ 0,\dots,n \}.\]</p><p>Notice that only the values of <code>β</code> of the recurrence coefficients <code>(α,β)</code> are required. The computation is based on equation (1.3.7) from Gautschi, W. &quot;Orthogonal Polynomials: Computation and Approximation&quot;. Whenever there exists an analytical expression for <code>β</code>, this function should be used.</p><p>The function is multiple-dispatched to facilitate its use with <code>AbstractOrthoPoly</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/scalar_product.jl#L142-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.computeSP" href="#PolyChaos.computeSP"><code>PolyChaos.computeSP</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Univariate</strong></p><pre><code class="nohighlight hljs">computeSP(a::AbstractVector{&lt;:Integer},α::AbstractVector{&lt;:Real},β::AbstractVector{&lt;:Real},nodes::AbstractVector{&lt;:Real},weights::AbstractVector{&lt;:Real};issymmetric::Bool=false)
computeSP(a::AbstractVector{&lt;:Integer},op::AbstractOrthoPoly;issymmetric=issymmetric(op))</code></pre><p><strong>Multivariate</strong></p><pre><code class="nohighlight hljs">computeSP( a::AbstractVector{&lt;:Integer},
           α::AbstractVector{&lt;:AbstractVector{&lt;:Real}},β::AbstractVector{&lt;:AbstractVector{&lt;:Real}},
           nodes::AbstractVector{&lt;:AbstractVector{&lt;:Real}},weights::AbstractVector{&lt;:AbstractVector{&lt;:Real}},
           ind::AbstractMatrix{&lt;:Integer};
           issymmetric::BitArray=falses(length(α)))
computeSP(a::AbstractVector{&lt;:Integer},op::AbstractVector,ind::AbstractMatrix{&lt;:Integer})
computeSP(a::AbstractVector{&lt;:Integer},mOP::MultiOrthoPoly)</code></pre><p>Computes the scalar product</p><p class="math-container">\[\langle \phi_{a_1},\phi_{a_2},\cdots,\phi_{a_n} \rangle,\]</p><p>where <code>n = length(a)</code>. This requires to provide the recurrence coefficients <code>(α,β)</code> and the quadrature rule <code>(nodes,weights)</code>, as well as the multi-index <code>ind</code>. If provided via the keyword <code>issymmetric</code>, symmetry of the weight function is exploited. All computations of the multivariate scalar products resort back to efficient computations of the univariate scalar products. Mathematically, this follows from Fubini&#39;s theorem.</p><p>The function is dispatched to facilitate its use with <code>AbstractOrthoPoly</code> and its quadrature rule <code>Quad</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li>Zero entries of <span>$a$</span> are removed automatically to simplify computations, which follows from</li></ul><p class="math-container">\[\langle \phi_i, \phi_j, \phi_0,\cdots,\phi_0 \rangle = \langle \phi_i, \phi_j \rangle,\]</p><p>because <code>\phi_0 = 1</code>.</p><ul><li>It is checked whether enough quadrature points are supplied to solve the integral exactly.</li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/scalar_product.jl#L56-L103">source</a></section></article><h2 id="Quadrature-Rules"><a class="docs-heading-anchor" href="#Quadrature-Rules">Quadrature Rules</a><a id="Quadrature-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Quadrature-Rules" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.fejer" href="#PolyChaos.fejer"><code>PolyChaos.fejer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fejer(N::Int)</code></pre><p>Fejer&#39;s first quadrature rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/quadrature_rules.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.fejer2" href="#PolyChaos.fejer2"><code>PolyChaos.fejer2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fejer2(n::Int)</code></pre><p>Fejer&#39;s second quadrature rule according to <a href="https://doi.org/10.1007/s10543-006-0045-4">Waldvogel, J. Bit Numer Math (2006) 46: 195</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/quadrature_rules.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.clenshaw_curtis" href="#PolyChaos.clenshaw_curtis"><code>PolyChaos.clenshaw_curtis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">clenshaw_curtis(n::Int)</code></pre><p>Clenshaw-Curtis quadrature according to <a href="https://doi.org/10.1007/s10543-006-0045-4">Waldvogel, J. Bit Numer Math (2006) 46: 195</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/quadrature_rules.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.quadgp" href="#PolyChaos.quadgp"><code>PolyChaos.quadgp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quadgp(weight::Function,lb::Real,ub::Real,N::Int=10;quadrature::Function=clenshaw_curtis,bnd::Float64=Inf)</code></pre><p>general purpose quadrature based on Gautschi, &quot;Orthogonal Polynomials: Computation and Approximation&quot;, Section 2.2.2, pp. 93-95</p><p>Compute the <code>N</code>-point quadrature rule for <code>weight</code> with support (<code>lb</code>, <code>ub</code>). The quadrature rule can be specified by the keyword <code>quadrature</code>. The keyword <code>bnd</code> sets the numerical value for infinity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/quadrature_rules.jl#L59-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.gauss" href="#PolyChaos.gauss"><code>PolyChaos.gauss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gauss(N::Int,α::AbstractVector{&lt;:Real},β::AbstractVector{&lt;:Real})
gauss(α::AbstractVector{&lt;:Real},β::AbstractVector{&lt;:Real})
gauss(N::Int,op::Union{OrthoPoly,AbstractCanonicalOrthoPoly})
gauss(op::Union{OrthoPoly,AbstractCanonicalOrthoPoly})</code></pre><p>Gauss quadrature rule, also known as Golub-Welsch algorithm</p><p><code>gauss()</code> generates the <code>N</code> Gauss quadrature nodes and weights for a given weight function. The weight function is represented by the <code>N</code> recurrence coefficients for the monic polynomials orthogonal with respect to the weight function.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function <code>gauss</code> accepts at most <code>N = length(α) - 1</code> quadrature points, hence providing at most an <code>(length(α) - 1)</code>-point quadrature rule.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If no <code>N</code> is provided, then <code>N = length(α) - 1</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/quadrature_rules.jl#L108-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.radau" href="#PolyChaos.radau"><code>PolyChaos.radau</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">radau(N::Int,α::AbstractVector{&lt;:Real},β::AbstractVector{&lt;:Real},end0::Real)
radau(α::AbstractVector{&lt;:Real},β::AbstractVector{&lt;:Real},end0::Real)
radau(N::Int,op::Union{OrthoPoly,AbstractCanonicalOrthoPoly},end0::Real)
radau(op::Union{OrthoPoly,AbstractCanonicalOrthoPoly},end0::Real)</code></pre><p>Gauss-Radau quadrature rule. Given a weight function encoded by the recurrence coefficients <code>(α,β)</code>for the associated orthogonal polynomials, the function generates the nodes and weights <code>(N+1)</code>-point Gauss-Radau quadrature rule for the weight function having a prescribed node <code>end0</code> (typically at one of the end points of the support interval of w, or outside thereof).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function <code>radau</code> accepts at most <code>N = length(α) - 2</code> as an input, hence providing at most an <code>(length(α) - 1)</code>-point quadrature rule.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Reference: OPQ: A MATLAB SUITE OF PROGRAMS FOR GENERATING ORTHOGONAL POLYNOMIALS AND RELATED QUADRATURE RULES by Walter Gautschi</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/quadrature_rules.jl#L144-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.lobatto" href="#PolyChaos.lobatto"><code>PolyChaos.lobatto</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lobatto(N::Int,α::AbstractVector{&lt;:Real},β::AbstractVector{&lt;:Real},endl::Real,endr::Real)
lobatto(α::AbstractVector{&lt;:Real},β::AbstractVector{&lt;:Real},endl::Real,endr::Real)
lobatto(N::Int,op::Union{OrthoPoly,AbstractCanonicalOrthoPoly},endl::Real,endr::Real)
lobatto(op::Union{OrthoPoly,AbstractCanonicalOrthoPoly},endl::Real,endr::Real)</code></pre><p>Gauss-Lobatto quadrature rule. Given a weight function encoded by the recurrence coefficients for the associated orthogonal polynomials, the function generates the nodes and weights of the <code>(N+2)</code>-point Gauss-Lobatto quadrature rule for the weight function, having two prescribed nodes <code>endl</code>, <code>endr</code> (typically the left and right end points of the support interval, or points to the left resp. to the right thereof).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function <code>radau</code> accepts at most <code>N = length(α) - 3</code> as an input, hence providing at most an <code>(length(α) - 1)</code>-point quadrature rule.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Reference: OPQ: A MATLAB SUITE OF PROGRAMS FOR GENERATING ORTHOGONAL POLYNOMIALS AND RELATED QUADRATURE RULES by Walter Gautschi</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/quadrature_rules.jl#L192-L215">source</a></section></article><h2 id="Polynomial-Chaos"><a class="docs-heading-anchor" href="#Polynomial-Chaos">Polynomial Chaos</a><a id="Polynomial-Chaos-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-Chaos" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Statistics.mean" href="#Statistics.mean"><code>Statistics.mean</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Univariate</strong></p><pre><code class="nohighlight hljs">mean(x::AbstractVector,op::AbstractOrthoPoly)</code></pre><p><strong>Multivariate</strong></p><pre><code class="nohighlight hljs">mean(x::AbstractVector,mop::MultiOrthoPoly)</code></pre><p>compute mean of random variable with PCE <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/polynomial_chaos.jl#L338-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.var" href="#Statistics.var"><code>Statistics.var</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Univariate</strong></p><pre><code class="nohighlight hljs">var(x::AbstractVector,op::AbstractOrthoPoly)
var(x::AbstractVector,t2::Tensor)</code></pre><p><strong>Multivariate</strong></p><pre><code class="nohighlight hljs">var(x::AbstractVector,mop::MultiOrthoPoly)
var(x::AbstractVector,t2::Tensor)</code></pre><p>compute variance of random variable with PCE <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/polynomial_chaos.jl#L360-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.std" href="#Statistics.std"><code>Statistics.std</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Univariate</strong></p><pre><code class="nohighlight hljs">std(x::AbstractVector,op::AbstractOrthoPoly)</code></pre><p><strong>Multivariate</strong></p><pre><code class="nohighlight hljs">std(x::AbstractVector,mop::MultiOrthoPoly)</code></pre><p>compute standard deviation of random variable with PCE <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/polynomial_chaos.jl#L393-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.sampleMeasure" href="#PolyChaos.sampleMeasure"><code>PolyChaos.sampleMeasure</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Univariate</strong></p><pre><code class="nohighlight hljs">sampleMeasure(n::Int,name::String,w::Function,dom::Tuple{&lt;:Real,&lt;:Real},symm::Bool,d::Dict;method::String=&quot;adaptiverejection&quot;)
sampleMeasure(n::Int,m::Measure;method::String=&quot;adaptiverejection&quot;)
sampleMeasure(n::Int,op::AbstractOrthoPoly;method::String=&quot;adaptiverejection&quot;)</code></pre><p>Draw <code>n</code> samples from the measure <code>m</code> described by its</p><ul><li><code>name</code></li><li>weight function <code>w</code>,</li><li>domain <code>dom</code>,</li><li>symmetry property <code>symm</code>,</li><li>and, if applicable, parameters stored in the dictionary <code>d</code>. By default, an adaptive rejection sampling method is used (from <a href="https://github.com/mauriciogtec/AdaptiveRejectionSampling.jl">AdaptiveRejectionSampling.jl</a>), unless it is a common random variable for which <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a> is used.</li></ul><p>The function is dispatched to accept <code>AbstractOrthoPoly</code>.</p><p><strong>Multivariate</strong></p><pre><code class="nohighlight hljs">sampleMeasure(n::Int,m::ProductMeasure;method::Vector{String}=[&quot;adaptiverejection&quot; for i=1:length(m.name)])
sampleMeasure(n::Int,mop::MultiOrthoPoly;method::Vector{String}=[&quot;adaptiverejection&quot; for i=1:length(mop.meas.name)])</code></pre><p>Multivariate extension, which provides an array of samples with <code>n</code> rows and as many columns as the multimeasure has univariate measures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/polynomial_chaos.jl#L147-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.evaluatePCE" href="#PolyChaos.evaluatePCE"><code>PolyChaos.evaluatePCE</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluatePCE(x::AbstractVector{&lt;:Real},ξ::AbstractVector{&lt;:Real},α::AbstractVector{&lt;:Real},β::AbstractVector{&lt;:Real})</code></pre><p>Evaluation of polynomial chaos expansion</p><p class="math-container">\[\mathsf{x} = \sum_{i=0}^{L} x_i \phi_i{\xi_j},\]</p><p>where <code>L+1 = length(x)</code> and <span>$x_j$</span> is the <span>$j$</span>th sample where <span>$j=1,\dots,m$</span> with <code>m = length(ξ)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/polynomial_chaos.jl#L244-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.samplePCE" href="#PolyChaos.samplePCE"><code>PolyChaos.samplePCE</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Univariate</strong></p><pre><code class="nohighlight hljs">samplePCE(n::Int,x::AbstractVector{&lt;:Real},op::AbstractOrthoPoly;method::String=&quot;adaptiverejection&quot;)</code></pre><p>Combines <a href="#PolyChaos.sampleMeasure"><code>sampleMeasure</code></a> and <a href="#PolyChaos.evaluatePCE"><code>evaluatePCE</code></a>, i.e. it first draws <code>n</code> samples from the measure, then evaluates the PCE for those samples.</p><p><strong>Multivariate</strong></p><pre><code class="nohighlight hljs">samplePCE(n::Int,x::AbstractVector{&lt;:Real},mop::MultiOrthoPoly;method::Vector{String}=[&quot;adaptiverejection&quot; for i=1:length(mop.meas.name)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/polynomial_chaos.jl#L304-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.calculateAffinePCE" href="#PolyChaos.calculateAffinePCE"><code>PolyChaos.calculateAffinePCE</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calculateAffinePCE(α::AbstractVector{&lt;:Real})</code></pre><p>Computes the affine PCE coefficients <span>$x_0$</span> and <span>$x_1$</span> from recurrence coefficients <span>$lpha$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/polynomial_chaos.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.convert2affinePCE" href="#PolyChaos.convert2affinePCE"><code>PolyChaos.convert2affinePCE</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert2affinePCE(mu::Real, sigma::Real, op::AbstractCanonicalOrthoPoly; kind::String)</code></pre><p>Computes the affine PCE coefficients <span>$x_0$</span> and <span>$x_1$</span> from</p><p class="math-container">\[X = a_1 + a_2 \Xi = x_0 + x_1 \phi_1(\Xi),\]</p><p>where <span>$\phi_1(t) = t-\alpha_0$</span> is the first-order monic basis polynomial.</p><p>Works for subtypes of AbstractCanonicalOrthoPoly. The keyword <code>kind in [&quot;lbub&quot;, &quot;μσ&quot;]</code> specifies whether <code>p1</code> and <code>p2</code> have the meaning of lower/upper bounds or mean/standard deviation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/polynomial_chaos.jl#L61-L76">source</a></section></article><h2 id="Auxiliary-Functions"><a class="docs-heading-anchor" href="#Auxiliary-Functions">Auxiliary Functions</a><a id="Auxiliary-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Auxiliary-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.nw" href="#PolyChaos.nw"><code>PolyChaos.nw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nw(q::EmptyQuad)
nw(q::AbstractQuad)
nw(opq::AbstractOrthoPoly)
nw(opq::AbstractVector)
nw(mop::MultiOrthoPoly)</code></pre><p>returns nodes and weights in matrix form</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/auxfuns.jl#L16-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.coeffs" href="#PolyChaos.coeffs"><code>PolyChaos.coeffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coeffs(op::AbstractOrthoPoly)
coeffs(op::AbstractVector)
coeffs(mop::MultiOrthoPoly)</code></pre><p>returns recurrence coefficients of in matrix form</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/auxfuns.jl#L48-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PolyChaos.integrate" href="#PolyChaos.integrate"><code>PolyChaos.integrate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrate(f::Function,nodes::AbstractVector{&lt;:Real},weights::AbstractVector{&lt;:Real})
integrate(f::Function,q::AbstractQuad)
integrate(f::Function,opq::AbstractOrthoPoly)</code></pre><p>integrate function <code>f</code> using quadrature rule specified via <code>nodes</code>, <code>weights</code>. For example <span>$\int_0^1 6x^5 = 1$</span> can be solved as follows:</p><pre><code class="language- hljs">julia&gt; opq = Uniform01OrthoPoly(3) # a quadrature rule is added by default

julia&gt; integrate(x -&gt; 6x^5, opq)
0.9999999999999993</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><ul><li>function <span>$f$</span> is assumed to return a scalar.</li><li>interval of integration is &quot;hidden&quot; in <code>nodes</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/auxfuns.jl#L69-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.issymmetric" href="#LinearAlgebra.issymmetric"><code>LinearAlgebra.issymmetric</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">issymmetric(m::AbstractMeasure)
issymmetric(op::AbstractOrthoPoly)</code></pre><p>Is the measure symmetric (around any point in the domain)?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/PolyChaos.jl/blob/54914108957f123f9e2c22a13dc4688067fbdf44/src/auxfuns.jl#L105-L112">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../math/">« Mathematical Background</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 13 March 2023 23:12">Monday 13 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
